#include <Arduino.h>
#include <avr/interrupt.h>
#include <ctype.h>
#include <Print.h>

#include "led_library.h"

#define MARGIN_SIZE = (BITMAP_SIZE - numCols)/2;
const int DEFAULT_SPEED = 75;
static LedScroller *s_inst = NULL;
static int s_marginCount = 0;

const uint8_t charset[][5] PROGMEM = {
                         {0x00, 0x00, 0x00, 0x00, 0x00}, // SPACE
                         {0x00, 0x00, 0x5F, 0x00, 0x00}, // !
                         {0x00, 0x03, 0x00, 0x03, 0x00}, // "
                         {0x14, 0x3E, 0x14, 0x3E, 0x14}, // #
                         {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // $
                         {0x43, 0x33, 0x08, 0x66, 0x61}, // %
                         {0x36, 0x49, 0x55, 0x22, 0x50}, // &
                         {0x00, 0x05, 0x03, 0x00, 0x00}, // '
                         {0x00, 0x1C, 0x22, 0x41, 0x00}, // (
                         {0x00, 0x41, 0x22, 0x1C, 0x00}, // )
                         {0x14, 0x08, 0x3E, 0x08, 0x14}, // *
                         {0x08, 0x08, 0x3E, 0x08, 0x08}, // +
                         {0x00, 0x50, 0x30, 0x00, 0x00}, // ,
                         {0x08, 0x08, 0x08, 0x08, 0x08}, // -
                         {0x00, 0x60, 0x60, 0x00, 0x00}, // .
                         {0x20, 0x10, 0x08, 0x04, 0x02}, // /
                         {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 0
                         {0x00, 0x04, 0x02, 0x7F, 0x00}, // 1
                         {0x42, 0x61, 0x51, 0x49, 0x46}, // 2
                         {0x22, 0x41, 0x49, 0x49, 0x36}, // 3
                         {0x18, 0x14, 0x12, 0x7F, 0x10}, // 4
                         {0x27, 0x45, 0x45, 0x45, 0x39}, // 5
                         {0x3E, 0x49, 0x49, 0x49, 0x32}, // 6
                         {0x01, 0x01, 0x71, 0x09, 0x07}, // 7
                         {0x36, 0x49, 0x49, 0x49, 0x36}, // 8
                         {0x26, 0x49, 0x49, 0x49, 0x3E}, // 9
                         {0x00, 0x36, 0x36, 0x00, 0x00}, // :
                         {0x00, 0x56, 0x36, 0x00, 0x00}, // ;
                         {0x08, 0x14, 0x22, 0x41, 0x00}, // <
                         {0x14, 0x14, 0x14, 0x14, 0x14}, // =
                         {0x00, 0x41, 0x22, 0x14, 0x08}, // >
                         {0x02, 0x01, 0x51, 0x09, 0x06}, // ?
                         {0x3E, 0x41, 0x59, 0x55, 0x5E}, // @
                         {0x7E, 0x09, 0x09, 0x09, 0x7E}, // A
                         {0x7F, 0x49, 0x49, 0x49, 0x36}, // B
                         {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
                         {0x7F, 0x41, 0x41, 0x41, 0x3E}, // D
                         {0x7F, 0x49, 0x49, 0x49, 0x41}, // E
                         {0x7F, 0x09, 0x09, 0x09, 0x01}, // F
                         {0x3E, 0x41, 0x41, 0x49, 0x3A}, // G
                         {0x7F, 0x08, 0x08, 0x08, 0x7F}, // H
                         {0x00, 0x41, 0x7F, 0x41, 0x00}, // I
                         {0x30, 0x40, 0x40, 0x40, 0x3F}, // J
                         {0x7F, 0x08, 0x14, 0x22, 0x41}, // K
                         {0x7F, 0x40, 0x40, 0x40, 0x40}, // L
                         {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // M
                         {0x7F, 0x02, 0x04, 0x08, 0x7F}, // N
                         {0x3E, 0x41, 0x41, 0x41, 0x3E}, // O
                         {0x7F, 0x09, 0x09, 0x09, 0x06}, // P
                         {0x1E, 0x21, 0x21, 0x21, 0x5E}, // Q
                         {0x7F, 0x09, 0x09, 0x09, 0x76}, // R
                         {0x26, 0x49, 0x49, 0x49, 0x32}, // S
                         {0x01, 0x01, 0x7F, 0x01, 0x01}, // T
                         {0x3F, 0x40, 0x40, 0x40, 0x3F}, // U
                         {0x1F, 0x20, 0x40, 0x20, 0x1F}, // V
                         {0x7F, 0x20, 0x10, 0x20, 0x7F}, // W
                         {0x41, 0x22, 0x1C, 0x22, 0x41}, // X
                         {0x07, 0x08, 0x70, 0x08, 0x07}, // Y
                         {0x61, 0x51, 0x49, 0x45, 0x43}, // Z
                         {0x00, 0x00, 0x00, 0x00, 0x00}, // place holder
                         {0x00, 0x7F, 0x41, 0x00, 0x00}, // [
                         {0x02, 0x04, 0x08, 0x10, 0x20}, // backslash
                         {0x00, 0x00, 0x41, 0x7F, 0x00}, // ]
                         {0x04, 0x02, 0x01, 0x02, 0x04}, // ^
                         {0x40, 0x40, 0x40, 0x40, 0x40}, // _
                         {0x00, 0x01, 0x02, 0x04, 0x00}, // `
                         
                         {0x20, 0x54, 0x54, 0x54, 0x78}, // a
                         {0x7F, 0x44, 0x44, 0x44, 0x38}, // b
                         {0x38, 0x44, 0x44, 0x44, 0x44}, // c
                         {0x38, 0x44, 0x44, 0x44, 0x7F}, // d
                         {0x38, 0x54, 0x54, 0x54, 0x18}, // e
                         {0x04, 0x04, 0x7E, 0x05, 0x05}, // f
                         {0x08, 0x54, 0x54, 0x54, 0x3C}, // g
                         {0x7F, 0x08, 0x04, 0x04, 0x78}, // h
                         {0x00, 0x44, 0x7D, 0x40, 0x00}, // i
                         {0x20, 0x40, 0x44, 0x3D, 0x00}, // j
                         {0x7F, 0x10, 0x28, 0x44, 0x00}, // k
                         {0x00, 0x41, 0x7F, 0x40, 0x00}, // l
                         {0x7C, 0x04, 0x78, 0x04, 0x78}, // m
                         {0x7C, 0x08, 0x04, 0x04, 0x78}, // n
                         {0x38, 0x44, 0x44, 0x44, 0x38}, // o
                         {0x7C, 0x14, 0x14, 0x14, 0x08}, // p
                         {0x08, 0x14, 0x14, 0x14, 0x7C}, // q
                         {0x00, 0x7C, 0x08, 0x04, 0x04}, // r
                         {0x48, 0x54, 0x54, 0x54, 0x20}, // s
                         {0x04, 0x04, 0x3F, 0x44, 0x44}, // t
                         {0x3C, 0x40, 0x40, 0x20, 0x7C}, // u
                         {0x1C, 0x20, 0x40, 0x20, 0x1C}, // v
                         {0x3C, 0x40, 0x30, 0x40, 0x3C}, // w
                         {0x44, 0x28, 0x10, 0x28, 0x44}, // x
                         {0x0C, 0x50, 0x50, 0x50, 0x3C}, // y
                         {0x44, 0x64, 0x54, 0x4C, 0x44}, // z
                         {0x00, 0x08, 0x36, 0x41, 0x41}, // {
                         {0x00, 0x00, 0x7F, 0x00, 0x00}, // |
                         {0x41, 0x41, 0x36, 0x08, 0x00}, // }
                         {0x02, 0x01, 0x02, 0x04, 0x02}  // ~
                       };
    
LedScroller::LedScroller(int clk, int dta, int numCols, int *ledPins)
    : _clk(clk), _dta(dta), _currentIndex(0), _currentColumn(0), 
    _currentMargin(BITMAP_SIZE/2), _numCols(numCols), _flipMode(RIGHTSIDE_UP), 
    _scrollMode(false), _scrollSpeed(DEFAULT_SPEED)
{
  static int defaultPins[] = {6,7,8,9,10,11,12,13};
  pinMode(_clk, OUTPUT);
  pinMode(_dta, OUTPUT);
  if (ledPins == NULL) {
    memcpy(_ledPins, defaultPins, sizeof(_ledPins));
  } else {
    memcpy(_ledPins, ledPins, sizeof(_ledPins));
  }
  for (int i=0; i < 8; ++i) {
    pinMode(_ledPins[i], OUTPUT);
    digitalWrite(ledPins[i], LOW);
  }
  
  digitalWrite(_clk, 0);
  digitalWrite(_dta, 0);

  // Set up the timer interrupt
  TCCR2A = 2;  // WGM 2, top=oc2a, clear timer at top
  TCCR2B = 0;
  OCR2A = 750;
  TCNT2 = 0;
  TIFR2 = 7;
  GTCCR |= (1 << PSRASY);
  TIMSK2 |= (1 << OCIE2A);
  TCCR2B = 3;  // clk/32

  clearDisplay();
  
  recalcMinMax();
  s_inst = this;
}

void LedScroller::recalcMinMax()
{
  s_marginCount = 0;
    _dataMin = 0; _dataMax = BITMAP_SIZE-1;
    for (; _dataMin < BITMAP_SIZE; ++_dataMin) if (_bitmap[_dataMin]) break;
    for (; _dataMax >= _dataMin; --_dataMax) if (_bitmap[_dataMax]) break; 
    if (_dataMax <= _dataMin) {
      _scrollMode = false;
    } else {
      if (_dataMin >= _numCols/2) {
        _dataMin -= _numCols/2;
      }
      _currentMargin = _dataMin;
    }
    Serial.print("dataMin "); Serial.print(_dataMin);
    Serial.print("dataMax "); Serial.println(_dataMax);
}

size_t LedScroller::write(uint8_t b)
{
  if (b >= ' ' && b <= '~')
  {
    b -= ' ';
    for (int i=0; _currentIndex < BITMAP_SIZE && i < 5; ++i)
    {
      _bitmap[_currentIndex++] = getByte(b,i);
    }
    if (_currentIndex < BITMAP_SIZE)
    {
      _bitmap[_currentIndex++] = 0;
    }
    return 1;
  }
  return 0;
}

void LedScroller::clearDisplay()
{
  memset(_bitmap, 0, sizeof(_bitmap));
}

uint8_t LedScroller::getByte(char c, uint8_t offset)
{ 
  uint8_t b = pgm_read_byte(&charset[(uint8_t)c][offset]); 
  return flipByte(b);
}

uint8_t LedScroller::flipByte(uint8_t b)
{
  uint8_t ret = 0;
  uint8_t bbb = 64, ccc = 1;
  for (uint8_t i=0; i < 7; ++i)
  {    
    if (b & bbb)
    {
      ret |= ccc;
    }
    bbb >>= 1;
    ccc <<= 1;
  }
  return ret;
}

ISR(TIMER2_COMPA_vect,ISR_NOBLOCK)
{
    s_inst->isr();
}

void LedScroller::isr() {
    int idx = _currentColumn;

    if (_flipMode == UPSIDE_DOWN)
    {
      idx = _numCols - _currentColumn - 5;
    }
    uint8_t b = _bitmap[idx + _currentMargin];
    if (_flipMode == UPSIDE_DOWN)
    {
      b = flipByte(b);
    }
    
    if (_currentColumn == 0)
    {
      digitalWrite(_dta, HIGH);
    }
    else
    {
      digitalWrite(_dta, LOW);
    }
    
    for (int i=0; i < 8; ++i) {
        digitalWrite(_ledPins[i], LOW);
    }

    digitalWrite(_clk, HIGH);
    digitalWrite(_clk, LOW);
    
    for (int i=128, j=0 ; i ; ++j, i >>= 1) {
        digitalWrite(_ledPins[j], (b & i));
    }
    if (++_currentColumn == _numCols)
    {
      _currentColumn = 0;
    }
    
    if (_scrollMode && ++s_marginCount == _scrollSpeed) {
      s_marginCount = 0;
      if (++_currentMargin == _dataMax) {
        _currentMargin = _dataMin;
      }
    }
    
    //digitalWrite(13, LOW);
}
